For the extension, I chose the binary search tree. Initially it was unbalanced, which resulted in poor performance due to sorted test input files nearing the BST worst case of O(n). To address this I used a simple balancing method which improved the worst-case runtime. This involves sorting the nodes, then starting the tree with the root at the centre, rather than at either side.

The decision to use a binary tree aimed to contrast efficiency and memory usage with the 27 way trie. I hypothesized before writing the inmplementation that the trie would outperform the BST in terms of speed, but may use more memory.

Tests were conducted using all 17 text files contained in the Words directory. Iterative loops simulate a scenario with increasing input size, enabling a performance comparison of the two trees. The tests were carried out on my laptop, and serve to give a rough idea of run time for both rather than an exact analysis.

The results were as follows:

| Loops | Words Added | Trie Time (s) | BST Time (s) |
|-------|-------------|---------------|--------------|
| 1     | 1606389     | 0.75          | 5.93         |
| 10    | 16063890    | 0.76          | 5.80         |
| 20    | 32127780    | 1.23          | 13.05        |
| 100   | 160638900   | 3.11          | 41.65        |
| 1000  | 1606389000  | 30.08         | 434.87       |

The trie consistently demonstrated superior performance, particularly as the input became much larger. This is due to its logarithmic depth traversal for searching and insertions. In contrast, the BST exhibited slower performance, a large part of this being due to the sorting.

The trie is the better data structure for a dictionary, with significant performance advantages. I also found the implementation of balancing the tree to be more complex. The BST does however remain a viable option for unsorted datasets. A next step would be to implement a hashing function for the binary tree, which would speed up insertions and searching enourmously.